defmodule Converter.Reader do
  @moduledoc """
  Read a CVE entry and extract useful info
  """

  require Logger

  # Entry point
  def read_json(input_file_name) do
    Logger.info("Began reading file #{input_file_name}")
    cve_lists =
      input_file_name
      |> File.read!()
      |> Jason.decode!()

    Logger.info("Began extracting informations of file #{input_file_name}")
    content =
      Map.get(cve_lists, "CVE_Items")
      |> Enum.map(&Converter.Reader.start_extraction(&1))
      |> Jason.encode!()

    output_file_name = "output-#{input_file_name}"

    Logger.info("Began writing #{input_file_name} CVEs to #{output_file_name}")

    File.write!(output_file_name, content)

    Logger.info("Finished writing #{input_file_name} CVEs to #{output_file_name}")
  end

  def start_extraction(entry) do
    {_entry, cve} =
      {entry, %{}}
      |> extract_basic_info()
      |> extract_products()
      |> extract_severity()

    cve
  end

  # Extract basic info about CVE
  def extract_basic_info({entry, cve}) do
    id = get_in(entry, ["cve", "CVE_data_meta", "ID"])
    [%{"value" => description}] = get_in(entry, ["cve", "description", "description_data"])

    cve =
      cve
      |> Map.put_new("id", id)
      |> Map.put_new("description", description)

    {entry, cve}
  end

  # Configurations part of the json, it's all about product and vendor

  def extract_products({entry, cve}) do
    configurations = Map.get(entry, "configurations")
    products = recursive_cpe_extraction(configurations)
    cve = Map.put_new(cve, "products", products)
    {entry, cve}
  end

  defp recursive_cpe_extraction(entry, acc \\ [])

  defp recursive_cpe_extraction(binary, acc) when is_binary(binary) do
    if String.starts_with?(binary, "cpe") do
      [_cpe, _cpe_version, _part, vendor, product, version, _] =
        String.split(binary, ":", parts: 7)

      affected_product = %{"vendor" => vendor, "product" => product, "version" => version}

      [affected_product | acc]
    else
      acc
    end
  end

  defp recursive_cpe_extraction(map, acc) when is_map(map) do
    Enum.reduce(map, acc, fn {_, v}, acc -> recursive_cpe_extraction(v, acc) end)
  end

  defp recursive_cpe_extraction(list, acc) when is_list(list) do
    Enum.reduce(list, acc, fn v, acc -> recursive_cpe_extraction(v, acc) end)
  end

  defp recursive_cpe_extraction(boolean, acc) when is_boolean(boolean) do
    acc
  end

  # Impact, it's all about severity

  def extract_severity({entry, cve}) do
    severity_v2 = get_in(entry, ["impact", "baseMetricV2", "severity"])
    severity_v3 = get_in(entry, ["impact", "baseMetricV3", "cvssV3", "baseSeverity"])

    cve =
      cve
      |> Map.put_new("severity_v2", severity_v2)
      |> Map.put_new("severity_v3", severity_v3)

    {entry, cve}
  end
end
